/**\file protocol.cpp
 * \brief the communication protocol implementation file for mashaling/unmashaling, this file is automatically generated from interface.dll
 */
#include "StdAfx.h"
#include "protocol.h"

#ifdef _DEBUG
	#define LOG_PROTOCOL
#endif

#ifdef NO_LOG_PROTOCOL
	#undef LOG_PROTOCOL
#endif

#ifdef LOG_PROTOCOL
#include "ProtocolLogHelper.h"
#endif
namespace Protocol
{

#ifdef LOG_PROTOCOL


void LogData(const ClientData* val)
{
	if(!val)
	{
		LogAppend("null");
		return;
	}
	LogAppend("{ ");
	LogData(val->Name);
	LogData(val->CPU);
	LogData(val->IdleTime);
	LogData(val->KernelTime);
	LogData(val->UserTime);
	LogData(val->CommitTotal);
	LogData(val->CommitLimit);
	LogData(val->CommitPeak);
	LogData(val->PhysicalTotal);
	LogData(val->PhysicalAvailable);
	LogData(val->SystemCache);
	LogData(val->KernelTotal);
	LogData(val->KernelPaged);
	LogData(val->KernelNonpaged);
	LogData(val->PageSize);
	LogData(val->HandleCount);
	LogData(val->ProcessCount);
	LogData(val->ThreadCount);
	LogAppend("}");
}
#endif

Error ClientData::Read(BinaryStreamOut& stream, ClientData** data)
{
	bool exist;
	CHECK(stream.GetValue(&exist));
	if(!exist)
	{
		*data = 0;
		return E_OK;
	}
	ClientData* obj = new ClientData();
	*data = obj;
	CHECK(stream.GetValue(&obj->Name));
	CHECK(stream.GetValue(&obj->CPU));
	CHECK(stream.GetValue(&obj->IdleTime));
	CHECK(stream.GetValue(&obj->KernelTime));
	CHECK(stream.GetValue(&obj->UserTime));
	CHECK(stream.GetValue(&obj->CommitTotal));
	CHECK(stream.GetValue(&obj->CommitLimit));
	CHECK(stream.GetValue(&obj->CommitPeak));
	CHECK(stream.GetValue(&obj->PhysicalTotal));
	CHECK(stream.GetValue(&obj->PhysicalAvailable));
	CHECK(stream.GetValue(&obj->SystemCache));
	CHECK(stream.GetValue(&obj->KernelTotal));
	CHECK(stream.GetValue(&obj->KernelPaged));
	CHECK(stream.GetValue(&obj->KernelNonpaged));
	CHECK(stream.GetValue(&obj->PageSize));
	CHECK(stream.GetValue(&obj->HandleCount));
	CHECK(stream.GetValue(&obj->ProcessCount));
	CHECK(stream.GetValue(&obj->ThreadCount));
	return E_OK;
};

void ClientData::Write(BinaryStreamIn& stream, const ClientData* data)
{
	if(!data)
	{
		stream.AddValue(false);
		return;
	}
		stream.AddValue(true);
	stream.AddValue(data->Name);
	stream.AddValue(data->CPU);
	stream.AddValue(data->IdleTime);
	stream.AddValue(data->KernelTime);
	stream.AddValue(data->UserTime);
	stream.AddValue(data->CommitTotal);
	stream.AddValue(data->CommitLimit);
	stream.AddValue(data->CommitPeak);
	stream.AddValue(data->PhysicalTotal);
	stream.AddValue(data->PhysicalAvailable);
	stream.AddValue(data->SystemCache);
	stream.AddValue(data->KernelTotal);
	stream.AddValue(data->KernelPaged);
	stream.AddValue(data->KernelNonpaged);
	stream.AddValue(data->PageSize);
	stream.AddValue(data->HandleCount);
	stream.AddValue(data->ProcessCount);
	stream.AddValue(data->ThreadCount);
};

Error IRemoteMonitor::ParseAndInvoke(IRemoteMonitor* service, BYTE* data, int length, BinaryStreamIn* retStream)
{
	BinaryStreamOut stream(data, length);
	int dispId;
	CHECK(stream.GetValue(&dispId));
	switch(dispId)
	{
	case 1: //UpdateData
		{
			ClientData* data;

			CHECK(ClientData::Read(stream, &data));

#ifdef LOG_PROTOCOL
			LogDebug("UpdateData ");
			LogData(data);
#endif

			Error err = service->UpdateData(data);
			retStream->AddValue((int)err.Check());
			if(err.Check())
				retStream->AddValue(string(err.ErrorMessage()));
		}break;
	default: return E_UnknownMethod;
	}
	return E_OK;
}

void IRemoteMonitorMarshaling::UpdateData(BinaryStreamIn* stream, ClientData* data)
{
	int dispId = 1;
	stream->AddValue((int)0);
	stream->AddValue(dispId);
	ClientData::Write(*stream, data);
	*(int*)stream->GetBuffer() = stream->GetSize() - 4;
}

};
